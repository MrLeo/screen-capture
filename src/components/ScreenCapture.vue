<template>
  <div style="position: relative; width: 500px; margin: 0 auto;">
    <video ref="desktop" autoplay style="width: 500px;"></video>
    <video ref="camera" autoplay style="position: absolute; width: 100px; top: 0; left: 0;"></video>
  </div>
  <div class="control">
    <a href="javascript:void(0);" @click="screenCapture" class="btn" :class="{recording: recordState}">{{btnText}}</a>
  </div>
  <transition-group name="list" tag="div" class="imgs" ref="imgs">
    <img v-for="item in screens" :key="item.time" :src="item.img" :alt="item.time">
  </transition-group>
</template>

<script setup>
import _ from 'lodash'
import { computed, nextTick, onMounted, reactive, ref, watch } from "vue"
import 'viewerjs/dist/viewer.css'
import Viewer from 'viewerjs' // https://github.com/fengyuanchen/viewerjs

const recordState = ref(false)
const desktop = ref(null)
const camera = ref(null)
// const desktop = ref(document.createElement("video"))
// const camera = ref(document.createElement("video"))
// desktop.value.autoplay = true
// camera.value.autoplay = true

const canvas = reactive({
  desktopCature: document.createElement("canvas"),
  cameraCature: document.createElement("canvas"),
  preview: document.createElement("canvas")
})
_.forEach(canvas, val => {
  val.width = window.screen.width
  val.height = window.screen.height
})

const times = ref(0)
const btnText = computed(()=> (recordState.value ? `🛑  截屏自动生成中: ${times.value}s` : '点击开始生成截屏'))

const imgs = ref(null)
const screens = ref([])
let viewer = ref(null)

onMounted(()=>{
  stopCapture()

  viewer.value = new Viewer(imgs.value.$el)
})

async function startCapture() {
  try {
    // https://developer.mozilla.org/zh-CN/docs/Web/API/Screen_Capture_API/%E4%BD%BF%E7%94%A8%E5%B1%8F%E5%B9%95%E6%8D%95%E8%8E%B7API
    desktop.value.srcObject = await navigator.mediaDevices.getDisplayMedia({ video: { cursor: "always" }, audio: false })
    console.log(`[LOG] -> startCapture ->`, desktop)
  } catch(err) {
    console.error("Error: " + err)
    new Map([
      [/AbortError/,'屏幕共享意外终止'],
      [/InvalidStateError/,'屏幕共享加载失败'],
      [/NotAllowedError/,'用户拒绝授予访问屏幕区域的权限，或者不允许当前浏览实例访问屏幕共享'],
      [/NotFoundError/,'没有可用于捕获的屏幕视频源'],
      [/NotReadableError/,'无法读取: 屏幕共享被其他资源占用'],
      [/OverconstrainedError/, '转换错误: 视频流解析失败'],
      [/TypeError/, '类型错误'],
      [/./, '浏览器不支持webrtc']
    ]).forEach((val,key)=> {
      if(key.test(""+err)) {
        alert(val)
        throw err
      }
    })
  }

  navigator.mediaDevices.getUserMedia({ audio: false, video: { width: 1280, height: 720 } }).then(function(mediaStream) {
    camera.value.srcObject = mediaStream
    camera.value.onloadedmetadata = function(e) {
      camera.value.play()
    }
  }).catch(function(err) { console.log(err.name + ": " + err.message); }); // 总是在最后检查错误
}

const stopCapture = () => {
  recordState.value=false

  try {
    const desktopSrcObject = desktop.value && desktop.value.srcObject
    if (desktopSrcObject && "getTracks" in desktopSrcObject) {
      const tracks = desktopSrcObject.getTracks()
      tracks.forEach(track => track.stop())
      desktop.value.srcObject = null
    }
  } catch (err) {
    console.log(`[error] -> stopCapture -> desktop`, err)
  }

  try {
    const cameraSrcObject = camera.value && camera.value.srcObject
    if (cameraSrcObject && "getTracks" in cameraSrcObject) {
      const tracks = cameraSrcObject.getTracks()
      tracks.forEach(track => track.stop())
      camera.value.srcObject = null
    }
  } catch (err) {
    console.error(`[error] -> stopCapture -> camera`, err)
  }
}

function drawCature (name, source) {
  const cvs = canvas[name]
  const ctx = cvs.getContext('2d')

  cvs.width = source.value.videoWidth
  cvs.height = source.value.videoHeight

  ctx.drawImage(
    desktop.value,
    0,
    0,
    cvs.width,
    cvs.height
  )

  return ctx
}

function drawImage () {
  try {
    drawCature('desktopCature', desktop)
    drawCature('cameraCature', camera)
  
    const ctx = drawCature('preview', desktop)
    if(!ctx) throw new Error('error in canvas.getContext') 
  
    // 矩形摄像头
    const cameraW = 200
    const cameraH = cameraW / (camera.value.videoWidth / camera.value.videoHeight)
    ctx.drawImage(camera.value, 0, 0, cameraW, cameraH)
  
    // 圆形摄像头
    // ctx.save()
    // const r = 200
    // ctx.arc(r, r, r, 0, 2 * Math.PI)
    // ctx.clip()
    // ctx.drawImage(camera.value, 0, 0, r * 2, r * 2)
    // ctx.restore()
  } catch (err) {
    console.error(`[LOG] -> drawImage -> err`, err)
    stopCapture()
  }
}

async function setHistory () {
  try {
    screens.value.unshift({
      img: canvas.preview.toDataURL(),
      desktop: canvas.desktopCature.toDataURL(),
      camera: canvas.cameraCature.toDataURL(),
      time: +new Date()
    })

    await nextTick()
    viewer.value.update()
  } catch (err) {
    console.log(`[LOG] -> setHistory -> err`, err)
    stopCapture()
  }
}

const addImg = () => {
  times.value = 5
  drawImage()
  setHistory()
}

let countdown = null

const clearCountdown = () => {
    clearInterval(countdown)
    countdown = null
    addImg()
}

watch(recordState, async (val) => {
  if ( val ) {
    if(!desktop.value.srcObject) {
      await startCapture()
    }

    // setTimeout(() => clearCountdown(),100)
    countdown = setInterval(() => {
      if(--times.value <= 0) addImg()
    }, 1000)
  } else {
    clearCountdown()
  }
})

function screenCapture(){
  recordState.value = !recordState.value
}
</script>

<style scoped>
.control{
  display: flex;
  align-items: center;
  justify-content: center;
  flex-direction: column;
}
.control .btn {
  border: 1px solid #eee;
  padding: 10px 30px;
  width:500px;
  text-decoration: none;
  color: rgb(0, 0, 0);
  text-align: center;
  margin: 16px;
  border-radius: 5px;
}
@keyframes recording { 
  from { background-color: rgba(255, 0, 0, 1); } 
  to { background-color: rgba(255, 0, 0, 0.5); }
}
.control .btn.recording {
  background-color: rgba(255, 0, 0, 1);
  color:#fff;
  animation: 0.5s linear 0s infinite alternate recording;
}

.imgs{
  display: flex;
  flex-wrap: wrap;
  align-items: center;
  justify-content: center;
}
.imgs img{
  margin: 10px;
  border: 1px solid #ccc;
  width: 100px;
  cursor: pointer;
}

.list-enter-active,
.list-leave-active, 
.list-move {
  transition: all 0.5s;
}
.list-enter-from,
.list-leave-to {
  opacity: 0;
  transform: translateY(-30px);
}
</style>
